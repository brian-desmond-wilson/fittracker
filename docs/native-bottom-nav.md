# Native Bottom Navigation (iOS)

The Capacitor shell gives us a WebView that renders the FitTracker UI. To stabilise the bottom navigation we render it natively and drive the WebView with JavaScript navigation events.

## 1. Structure

Inside the `ios/` project generated by Capacitor you will find:

```
ios/
 └── App/
     ├── App/
     │   ├── AppDelegate.swift
     │   └── SceneDelegate.swift
     └── App.xcodeproj / App.xcworkspace
```

We will:

1. Replace the default `CAPBridgeViewController` root with a custom container.
2. Embed the Capacitor bridge (WebView) above the tab bar.
3. Send navigation commands to the WebView when a tab is tapped.

## 2. Create a `RootViewController`

Add a new Swift file at `ios/App/App/RootViewController.swift`:

```swift
import UIKit
import Capacitor
import WebKit

final class RootViewController: UIViewController {
    private let bridgeViewController: CAPBridgeViewController
    private let tabBar = UITabBar()

    private let tabs: [(title: String, path: String, icon: String)] = [
        ("Home", "/", "house"),
        ("Schedule", "/schedule", "calendar"),
        ("Track", "/track", "plus.circle"),
        ("Progress", "/progress", "chart.bar"),
        ("Profile", "/profile", "person")
    ]

    init(bridgeViewController: CAPBridgeViewController) {
        self.bridgeViewController = bridgeViewController
        super.init(nibName: nil, bundle: nil)
    }

    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        view.backgroundColor = .black

        addChild(bridgeViewController)
        view.addSubview(bridgeViewController.view)
        bridgeViewController.didMove(toParent: self)

        tabBar.items = tabs.enumerated().map { index, tab in
            let item = UITabBarItem(title: tab.title,
                                    image: UIImage(systemName: tab.icon),
                                    tag: index)
            return item
        }
        tabBar.selectedItem = tabBar.items?.first
        tabBar.delegate = self
        tabBar.backgroundEffect = UIBlurEffect(style: .systemChromeMaterialDark)
        tabBar.clipsToBounds = true

        view.addSubview(tabBar)
    }

    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()

        let safe = view.safeAreaInsets
        let tabHeight: CGFloat = 60 + safe.bottom

        tabBar.frame = CGRect(
            x: 0,
            y: view.bounds.height - tabHeight,
            width: view.bounds.width,
            height: tabHeight
        )

        bridgeViewController.view.frame = CGRect(
            x: 0,
            y: 0,
            width: view.bounds.width,
            height: view.bounds.height - tabHeight + safe.bottom
        )
        bridgeViewController.view.insetsLayoutMarginsFromSafeArea = false
    }
}

extension RootViewController: UITabBarDelegate {
    func tabBar(_ tabBar: UITabBar, didSelect item: UITabBarItem) {
        guard let index = tabBar.items?.firstIndex(of: item) else { return }
        let targetPath = tabs[index].path
        bridgeViewController.bridge?.webView?.evaluateJavaScript("""
            window.history.pushState({}, "", "\(targetPath)");
            window.dispatchEvent(new Event("popstate"));
        """, completionHandler: nil)
    }
}
```

Notes:

- We use SF Symbols for quick icons (`house`, `calendar`, etc.). Replace with custom assets later.
- Navigating is done by pushing to the browser history and dispatching `popstate`, which Next.js listens to.
- The WebView is resized to account for the tab bar; the web bottom nav should be hidden (next section).

## 3. Wire the root controller

Open `ios/App/App/AppDelegate.swift` and update `application(_:didFinishLaunchingWithOptions:)`:

```swift
import Capacitor

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?
    var bridgeViewController: CAPBridgeViewController?

    func application(
        _ application: UIApplication,
        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
    ) -> Bool {
        let bridgeVC = CAPBridgeViewController()
        bridgeViewController = bridgeVC

        let window = UIWindow(frame: UIScreen.main.bounds)
        window.rootViewController = RootViewController(bridgeViewController: bridgeVC)
        window.makeKeyAndVisible()

        self.window = window
        return true
    }
}
```

If your project already uses `SceneDelegate`, perform the same setup in `scene(_:willConnectTo:options:)`.

## 4. Hide the web nav when running inside Capacitor

Add a check to the Next.js app that hides the existing bottom nav when `window.Capacitor` is available. Example:

```tsx
// components/nav/bottom-nav.tsx
if (typeof window !== "undefined" && window.Capacitor) {
  return null;
}
```

or apply a body class in `head` `<script>` that the native shell injects (`document.body.classList.add("native-shell")`).

## 5. Intercept navigation events from the web side (optional)

If the user navigates from within the WebView (e.g., clicking a link), you can broadcast the active path back to native and highlight the correct tab:

1. Inside the web app, add:

   ```ts
   if (typeof window !== "undefined" && (window as any).Capacitor) {
     window.addEventListener("popstate", () => {
       (window as any).Capacitor?.Plugins?.App?.notifyListeners("routeChange", {
         pathname: window.location.pathname,
       });
     });
   }
   ```

2. In `RootViewController`, register for the event:

   ```swift
   CAPBridge.handleEvents(forPlugin: "App", listener: "routeChange") { data in
       if let pathname = data?["pathname"] as? String,
          let index = self.tabs.firstIndex(where: { $0.path == pathname }) {
           DispatchQueue.main.async {
               self.tabBar.selectedItem = self.tabBar.items?[index]
           }
       }
   }
   ```

This keeps the native tab bar in sync with deep links or client-side routing.

## 6. Build & run

- `npm run build`
- `npm run cap:sync`
- `npm run cap:open:ios`
- Run the **App** target in Xcode.

You should now see the native tab bar anchored to the bottom with the WebView scrolling behind it. Keyboard dismissal no longer affects the bar because UIKit owns the layout.

## 7. Next steps

- Replace the SF Symbol icons with custom assets.
- Style the tab bar to match the brand (rounded corners, blur, etc.).
- Handle Android (similar approach using Kotlin + BottomNavigationView).
- Decide how to distribute: TestFlight → App Store.
